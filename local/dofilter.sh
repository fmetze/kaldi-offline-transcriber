#!/bin/bash

MODE="default"

while [[ $# -ge 1 ]]
do
    key="$1"

    case $key in
	-n|--numeric)
	    MODE="num"
	    ;;
	-s|--searchpath)
	    # see how we can read the value of an argument
	    SEARCHPATH="$2"
	    shift # past argument
	    ;;
	--default)
	    MODE="default"
	    ;;
	*)
            # unknown option
	    ;;
    esac
    shift # past argument or value
done

case $MODE in
    default)
	# this is the 'default' mode where numbers (digits) are being filtered out
	awk ' { gsub ("^(zero|one|two|three|four|five|six|seven|eight|nine|ten|tens|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|hundreds|thousand|thousands|million|millions|billion|billions|[0-9]+)$", "###", $5); print $0 } '
	;;
    num)
	# this works with numbers that have been generated by the num2words (or so) python package
	# it converts them back into numbers, no matter how they were being pronounced (hopefully)
	# seventy-six -> 76, hundred -> 00 (and then collapsing)
	# will do numbers up to 99999
	# the awk part combines multiple individual number-words (in field 5) into a number, "3 hundred 76" -> 376
	#   problematic: one thousand eight four -> 10084 (one thousand eight -> 1008, then 4 appended)
	#                "forty three" -> 403
	cat /dev/stdin | sed 's/ and / /g' | \
	    sed -e 's/\btwenty-/2-/' -e 's/\bthirty-/3-/' -e 's/\bforty-/4-/' \
		-e 's/\bfifty-/5-/'  -e 's/\bsixty-/6-/'  -e 's/\bseventy-/7-/' \
		-e 's/\beighty-/8-/' -e 's/\bninety-/9-/' | \
	    sed -e 's/\boh\b/0/'        -e 's/\bzero\b/0/' \
		-e 's/\bten\b/10/'      -e 's/\beleven\b/11/'    -e 's/\btwelve\b/12/' \
		-e 's/\bthirteen\b/13/' -e 's/\bfourteen\b/14/'  -e 's/\bfifteen\b/15/' \
		-e 's/\bsixteen\b/16/'  -e 's/\bseventeen\b/17/' -e 's/\beighteen\b/18/' \
		-e 's/\bnineteen\b/19/' -e 's/\btwenty\b/20/'    -e 's/\bthirty\b/30/' \
		-e 's/\bforty\b/40/'    -e 's/\bfifty\b/50/'     -e 's/\bsixty\b/60/' \
		-e 's/\bseventy\b/70/'  -e 's/\beighty\b/80/'   -e 's/\bninety\b/90/' | \
	    sed -e 's/\(-*\)\bone\b/1/'   -e 's/\(-*\)\btwo\b/2/' \
		-e 's/\(-*\)\bthree\b/3/' -e 's/\(-*\)\bfour\b/4/' \
		-e 's/\(-*\)\bfive\b/5/'  -e 's/\(-*\)\bsix\b/6/' \
		-e 's/\(-*\)\bseven\b/7/' -e 's/\(-*\)\beight\b/8/' \
		-e 's/\(-*\)\bnine\b/9/' | \
	    sed -e 's/hundred/00/' -e 's/thousand/000/' | \
	    awk '{ while ($5 == int($5) || $5 == 0 || (length(a) > 0 && match ($5, "and"))) { \
                   if (match ($5, "and")) { \
                     $5=a \
                   } else if (match ($5, "00$") && length (a)) { \
                     sub ("00", "", a); $5=a$5 \
                   } else if (match ($5, "00$") && length (a) == 0) { \
                     $5=1$5 \
                   } else if (match (a,  "00$")) { \
                     t=$5; gsub (".", "0", t); c=$5; $5=a; sub (t"$", c, $5) \
                   } else { \
                     $5=a$5 \
                   }; \
                   a=$5; b=$0; bo=$1; \
                   if (getline==0) { $0="" }; \
                   if ($5 != int($5) || $1 != bo) { print b; a="" } \
                 }; if ($0 != "") { print $0 } }'
	;;
esac

# 12 thousand
# 8 hundred
# ten etc only as whole word \b (on Linux) or [[:<:]] (on Mac)
# deal with 'and' somehow
# maybe do ALT syntax?
